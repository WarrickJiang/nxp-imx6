From b38311accc8a2ac89c5f3d911c519be537e6082e Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 17 May 2018 17:52:22 +0800
Subject: [PATCH] imx6sx:Add support for seco b08 board

Patch picks from:
git://secogit.seco.com/imx6_release/u-boot-2015-04-secoboards-imx6sx-rel.git

Add support seco b08 board, implement imx6sx soc & 1GB DDR.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/arm/cpu/armv7/mx6/Kconfig           |    7 +
 arch/arm/include/asm/arch-mx6/imx-regs.h |    2 +
 board/freescale/b08/Kconfig              |   15 +
 board/freescale/b08/MAINTAINERS          |    6 +
 board/freescale/b08/Makefile             |    7 +
 board/freescale/b08/b08.c                | 1239 ++++++++++++++++++++++++++++++
 board/freescale/b08/detectboard.c        |  115 +++
 board/freescale/b08/detectboard.h        |   14 +
 board/freescale/b08/seco_b08.cfg         |  155 ++++
 board/freescale/b08/seco_b08_basic.cfg   |  155 ++++
 board/freescale/b08/spl.c                |  174 +++++
 board/freescale/common/Makefile          |    3 +-
 board/freescale/common/pfuze.c           |   11 +
 configs/seco_b08_defconfig               |    5 +
 include/config_cmd_default.h             |   44 ++
 include/configs/seco_b08.h               |  446 +++++++++++
 include/configs/seco_b08_bootdevice.h    |    1 +
 include/power/pfuze3000_pmic.h           |    2 +
 18 files changed, 2400 insertions(+), 1 deletion(-)
 create mode 100644 board/freescale/b08/Kconfig
 create mode 100644 board/freescale/b08/MAINTAINERS
 create mode 100644 board/freescale/b08/Makefile
 create mode 100644 board/freescale/b08/b08.c
 create mode 100644 board/freescale/b08/detectboard.c
 create mode 100644 board/freescale/b08/detectboard.h
 create mode 100644 board/freescale/b08/seco_b08.cfg
 create mode 100644 board/freescale/b08/seco_b08_basic.cfg
 create mode 100644 board/freescale/b08/spl.c
 create mode 100644 configs/seco_b08_defconfig
 create mode 100644 include/config_cmd_default.h
 create mode 100644 include/configs/seco_b08.h
 create mode 100644 include/configs/seco_b08_bootdevice.h

diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index d9f2697..af10f8c 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -127,6 +127,12 @@ config TARGET_MX6SXSABREAUTO
         select DM
         select DM_THERMAL
 
+config TARGET_SECO_B08
+	bool "mx6sx_seco_b08"
+        select MX6SX
+        select DM
+        select DM_THERMAL
+
 config TARGET_MX6UL_9X9_EVK
 	bool "mx6ul_9x9_evk"
 	select MX6UL
@@ -259,6 +265,7 @@ source "board/freescale/mx6sllevk/Kconfig"
 source "board/freescale/mx6sll_arm2/Kconfig"
 source "board/freescale/mx6sxsabresd/Kconfig"
 source "board/freescale/mx6sxsabreauto/Kconfig"
+source "board/freescale/b08/Kconfig"
 source "board/freescale/mx6ul_14x14_evk/Kconfig"
 source "board/freescale/mx6sx_17x17_arm2/Kconfig"
 source "board/freescale/mx6sx_19x19_arm2/Kconfig"
diff --git a/arch/arm/include/asm/arch-mx6/imx-regs.h b/arch/arm/include/asm/arch-mx6/imx-regs.h
index 40f8053..d960883 100644
--- a/arch/arm/include/asm/arch-mx6/imx-regs.h
+++ b/arch/arm/include/asm/arch-mx6/imx-regs.h
@@ -151,7 +151,9 @@
 #define MX6SL_UART5_BASE_ADDR       (ATZ1_BASE_ADDR + 0x18000)
 #define MX6SLL_UART4_BASE_ADDR      (ATZ1_BASE_ADDR + 0x18000)
 #define MX6UL_UART7_BASE_ADDR       (ATZ1_BASE_ADDR + 0x18000)
+#if !defined(CONFIG_MX6SX)
 #define ECSPI5_BASE_ADDR            (ATZ1_BASE_ADDR + 0x18000)
+#endif
 
 #define UART1_BASE                  (ATZ1_BASE_ADDR + 0x20000)
 
diff --git a/board/freescale/b08/Kconfig b/board/freescale/b08/Kconfig
new file mode 100644
index 0000000..c47fbce4
--- /dev/null
+++ b/board/freescale/b08/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_SECO_B08
+
+config SYS_BOARD
+	default "b08"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "seco_b08"
+
+endif
diff --git a/board/freescale/b08/MAINTAINERS b/board/freescale/b08/MAINTAINERS
new file mode 100644
index 0000000..874c279
--- /dev/null
+++ b/board/freescale/b08/MAINTAINERS
@@ -0,0 +1,6 @@
+SECO B08 BOARD
+M:	Giuseppe Pagano <giuseppe.pagano@seco.com>
+S:	Maintained
+F:	board/seco/b08/
+F:	include/configs/seco_b08.h
+F:	configs/seco_b08_defconfig
diff --git a/board/freescale/b08/Makefile b/board/freescale/b08/Makefile
new file mode 100644
index 0000000..67f6a74
--- /dev/null
+++ b/board/freescale/b08/Makefile
@@ -0,0 +1,7 @@
+# (C) Copyright 2015 UDOO Team
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := b08.o detectboard.o
+obj-$(CONFIG_SPL_BUILD)  += spl.o
diff --git a/board/freescale/b08/b08.c b/board/freescale/b08/b08.c
new file mode 100644
index 0000000..572be48
--- /dev/null
+++ b/board/freescale/b08/b08.c
@@ -0,0 +1,1239 @@
+/*
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) Jasbir Matharu
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <dm.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#include <malloc.h>
+#include "detectboard.h"
+
+#ifdef CONFIG_MXC_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_MED   |                                   \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_MED   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_40ohm)
+
+#define WDOG_PAD_CTRL (PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+
+#define DIO_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_34ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+#define DIO_PAD_CFG   (MUX_PAD_CTRL(DIO_PAD_CTRL) | MUX_MODE_SION)
+
+int dram_init(void)
+{
+	int ddr_mb = 1024;
+	int board_variant = detect_board();
+	if (board_variant == SECO_B08_TYPE_BASIC) {
+		ddr_mb = 512;
+	}
+	
+	gd->ram_size = ((ulong)ddr_mb * 1024 * 1024);
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	
+	/* CD pin */    
+	MX6_PAD_SD1_DATA0__GPIO6_IO_2 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* Power */
+	MX6_PAD_SD1_CMD__GPIO6_IO_1 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads_reset[] = {
+	MX6_PAD_SD2_CLK__GPIO6_IO_6    | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_SD2_CMD__GPIO6_IO_7    | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_SD2_DATA0__GPIO6_IO_8  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_SD2_DATA1__GPIO6_IO_9  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_SD2_DATA2__GPIO6_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_SD2_DATA3__GPIO6_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__GPIO6_IO_2  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_SD1_CMD__GPIO6_IO_1    | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+    /* Configured for WLAN */
+	MX6_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA0__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA1__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA2__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DATA3__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+    /* Configured for eMMC */
+	MX6_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA4__USDHC4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA5__USDHC4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA6__USDHC4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD4_DATA7__USDHC4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const gpio_pads[] = {
+
+    MX6_PAD_NAND_DATA02__GPIO4_IO_6 | MUX_PAD_CTRL(NO_PAD_CTRL), // LED
+    MX6_PAD_SD1_CLK__GPIO6_IO_0   | MUX_PAD_CTRL(NO_PAD_CTRL),   // LED
+
+    MX6_PAD_KEY_COL3__GPIO2_IO_13 | MUX_PAD_CTRL(NO_PAD_CTRL),     // Gyro interrupt
+    MX6_PAD_NAND_WE_B__GPIO4_IO_14 | MUX_PAD_CTRL(NO_PAD_CTRL),    // Mag interrupt
+    MX6_PAD_QSPI1B_DATA2__GPIO4_IO_26 | MUX_PAD_CTRL(NO_PAD_CTRL), // Accel interrupt
+
+    MX6_PAD_SD1_DATA2__GPIO6_IO_4 | MUX_PAD_CTRL(NO_PAD_CTRL),  // Touch interrupt
+    MX6_PAD_SD1_DATA3__GPIO6_IO_5 | MUX_PAD_CTRL(NO_PAD_CTRL),  // Touch reset
+
+    MX6_PAD_NAND_READY_B__GPIO4_IO_13 | MUX_PAD_CTRL(NO_PAD_CTRL),  // recognition GPIOs - Connected to R184
+    MX6_PAD_NAND_ALE__GPIO4_IO_0 | MUX_PAD_CTRL(NO_PAD_CTRL),       // recognition GPIOs - Connected to R185
+
+    // Multiplexer pins for GPIO/ADC (J5)
+    MX6_PAD_RGMII2_TXC__GPIO5_IO_23 | MUX_PAD_CTRL(NO_PAD_CTRL),    // MUX_A
+    MX6_PAD_RGMII2_RX_CTL__GPIO5_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL), // MUX_B
+    MX6_PAD_QSPI1A_SCLK__GPIO4_IO_21 | MUX_PAD_CTRL(NO_PAD_CTRL),   // MUX_C
+    MX6_PAD_QSPI1A_SS0_B__GPIO4_IO_22 | MUX_PAD_CTRL(NO_PAD_CTRL),  // MUX_D
+    MX6_PAD_QSPI1A_DATA2__GPIO4_IO_18 | MUX_PAD_CTRL(NO_PAD_CTRL),  // MUX_E
+    MX6_PAD_QSPI1A_DATA3__GPIO4_IO_19 | MUX_PAD_CTRL(NO_PAD_CTRL),  // MUX_F
+};
+
+static iomux_v3_cfg_t const wdog_b_pad = {
+	MX6_PAD_GPIO1_IO13__GPIO1_IO_13 | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const peri_3v3_pads[] = {
+	MX6_PAD_QSPI1A_DATA0__GPIO4_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_RXC__ENET1_RX_ER | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__GPIO2_IO_9 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6_PAD_ENET1_CRS__GPIO2_IO_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const phy_control_pads[] = {
+	/* 25MHz Ethernet PHY Clock */
+	MX6_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+};
+
+static int setup_fec(int fec_id)
+{
+	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	int reg;
+
+	imx_iomux_v3_setup_multiple_pads(phy_control_pads,
+					 ARRAY_SIZE(phy_control_pads));
+
+	/* Reset PHY */
+	gpio_direction_output(IMX_GPIO_NR(2, 1) , 0);
+	udelay(500 + 10);
+	gpio_set_value(IMX_GPIO_NR(2, 1), 1);
+	udelay(100 + 10);
+
+	reg = readl(&anatop->pll_enet);
+	reg |= BM_ANADIG_PLL_ENET_REF_25M_ENABLE;
+	writel(reg, &anatop->pll_enet);
+
+	return enable_fec_anatop_clock(fec_id, ENET_25MHZ);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	uint32_t base = IMX_FEC_BASE;
+	struct mii_dev *bus = NULL;
+	struct phy_device *phydev = NULL;
+	int ret;
+
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+
+	setup_fec(CONFIG_FEC_ENET_DEV);
+
+	bus = fec_get_miibus(base, CONFIG_FEC_ENET_DEV);
+	if (!bus)
+		return 0;
+
+	phydev = phy_find_by_mask(bus, (0x1 << CONFIG_FEC_MXC_PHYADDR), PHY_INTERFACE_MODE_RMII);
+
+	if (!phydev) {
+		free(bus);
+		return 0;
+	}
+	printf("using phy at %d\n", phydev->addr);
+	ret  = fec_probe(bis, CONFIG_FEC_ENET_DEV, base, bus, phydev);
+	if (ret) {
+		printf("FEC MXC: %s:failed\n", __func__);
+		free(phydev);
+		free(bus);
+	}
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+static void setup_iomux_gpio(void)
+{
+    imx_iomux_v3_setup_multiple_pads(gpio_pads, ARRAY_SIZE(gpio_pads));
+
+    gpio_direction_input(IMX_GPIO_NR(2,13)); // Gyro interrupt
+    gpio_direction_input(IMX_GPIO_NR(4,14)); // Mag interrupt
+    gpio_direction_input(IMX_GPIO_NR(4,26)); // Accel interupt
+    gpio_direction_input(IMX_GPIO_NR(2,4));  // Touch interrupt
+
+    gpio_direction_input(IMX_GPIO_NR(4,13));  // recognition GPIOs - Connected to R184
+    gpio_direction_input(IMX_GPIO_NR(4,0));   // recognition GPIOs - Connected to R185
+
+    gpio_direction_output(IMX_GPIO_NR(4,6), 0);	 // LED
+    gpio_direction_output(IMX_GPIO_NR(6,0), 1);  // LED
+
+    gpio_direction_output(IMX_GPIO_NR(5,23), 0); // MUX_A
+    gpio_direction_output(IMX_GPIO_NR(5,16), 0); // MUX_B
+    gpio_direction_output(IMX_GPIO_NR(4,21), 0); // MUX_C
+    gpio_direction_output(IMX_GPIO_NR(4,22), 0); // MUX_D
+    gpio_direction_output(IMX_GPIO_NR(4,18), 0); // MUX_E
+    gpio_direction_output(IMX_GPIO_NR(4,19), 0); // MUX_F
+};
+
+static iomux_v3_cfg_t const wl1831_control_pads[] = {
+	/* WL1831 - WiFi enable */
+	MX6_PAD_KEY_COL2__GPIO2_IO_12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* WL1831 - Bt enable */
+	MX6_PAD_KEY_ROW2__GPIO2_IO_17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_wl1831(void)
+{
+	imx_iomux_v3_setup_multiple_pads(wl1831_control_pads, ARRAY_SIZE(wl1831_control_pads));
+
+	gpio_direction_output(IMX_GPIO_NR(2,12), 0); // WL1831 - WiFi enable
+	gpio_direction_output(IMX_GPIO_NR(2,17), 0); // WL1831 - Bt enable
+}
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* CABC enable */
+	MX6_PAD_QSPI1B_DATA3__GPIO4_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6_PAD_SD1_DATA1__GPIO6_IO_3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA18__LCDIF1_DATA_18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA19__LCDIF1_DATA_19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA20__LCDIF1_DATA_20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA21__LCDIF1_DATA_21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA22__LCDIF1_DATA_22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_DATA23__LCDIF1_DATA_23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* CEC Clock */
+	MX6_PAD_GPIO1_IO12__CCM_CLKO2 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_lvds(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+	enable_lvds(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* Enable CABC */
+	gpio_direction_output(IMX_GPIO_NR(4, 27) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(6, 3) , 1);
+}
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	// enable_lcdif_clock(dev->lcdif_base_addr);
+	// 
+	// imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+	// 
+	// /* HDMI interrupt */
+	// gpio_direction_input(IMX_GPIO_NR(3, 27));
+	// 
+	// /* Set clock CCM_CLKO2 to 12MHz */
+	// struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	// int reg;
+	// reg = readl(&mxc_ccm->ccosr);
+	// reg |= (MXC_CCM_CCOSR_CKO2_EN_OFFSET  |
+	// 	1 << MXC_CCM_CCOSR_CKO2_DIV_OFFSET |
+	// 	14 << MXC_CCM_CCOSR_CKO2_SEL_OFFSET );
+	// 
+	// /* Initialise HDMI controller */
+	// tda19988_init();
+	// tda19988_reset();
+	// tda19988_fb_mode(dev->mode);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF2_BASE_ADDR,
+	.depth = 18,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+        /*
+         * Attached to TDA19988. For now set default resolution to
+         * 1280x720@60 this should work for both DVI and HDMI sources.
+         */
+		.name			= "MCIMX28LCD",
+		.xres           = 1280,
+		.yres           = 720,
+		.pixclock       = 13468, // 74.250 MHz
+		.left_margin    = 220,
+		.right_margin   = 110,
+		.upper_margin   = 20,
+		.lower_margin   = 5,
+		.hsync_len      = 40,
+		.vsync_len      = 5,
+		.sync           = FB_SYNC_VERT_HIGH_ACT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+static struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C3 */
+struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_KEY_COL4__I2C3_SCL | PC,
+		.gpio_mode = MX6_PAD_KEY_COL4__GPIO2_IO_14 | PC,
+		.gp = IMX_GPIO_NR(2, 14),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_KEY_ROW4__I2C3_SDA | PC,
+		.gpio_mode = MX6_PAD_KEY_ROW4__GPIO2_IO_19 | PC,
+		.gp = IMX_GPIO_NR(2, 19),
+	},
+};
+
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(PFUZE3000_I2C_BUS);
+	if (ret)
+		return ret;
+
+	p = pmic_get("PFUZE3000");
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(p, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(p, PFUZE3000_REVID, &rev_id);
+	printf("PMIC:  PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_read(p, PFUZE3000_LDOGCTL, &reg);
+	reg |= 0x1;
+	pmic_reg_write(p, PFUZE3000_LDOGCTL, reg);
+
+	if (pmic_reg_write(p, PFUZE3000_SW1AMODE, 0xc)) {
+		printf("PMIC: Set SW1AMODE error!\n");
+		return -1;
+	}
+
+	if (pmic_reg_write(p, PFUZE3000_SW1BMODE, 0xc)) {
+		printf("PMIC: Set SW1BMODE error!\n");
+		return -1;
+	}
+	
+	if (pmic_reg_write(p, PFUZE3000_SW2MODE, 0xc)) {
+		printf("PMIC: Set SW2MODE error!\n");
+		return -1;
+	}
+	
+	if (pmic_reg_write(p, PFUZE3000_SW3MODE, 0xc)) {
+		printf("PMIC: Set SW3MODE error!\n");
+		return -1;
+	}
+
+	/* set SW1A standby volatage 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1ASTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE3000_SW1AB_SETP(9750);
+	if (pmic_reg_write(p, PFUZE3000_SW1ASTBY, reg)) {
+		printf("PMIC: Set SW1ASTBY error!\n");
+		return -1;
+	}
+	
+	/* set SW1B standby volatage 0.975V */
+	pmic_reg_read(p, PFUZE3000_SW1BSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE3000_SW1AB_SETP(9750);
+	if (pmic_reg_write(p, PFUZE3000_SW1BSTBY, reg)) {
+		printf("PMIC: Set SW1BSTBY error!\n");
+		return -1;
+	}
+
+	/* set SW1A/VDD_ARM_IN step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(p, PFUZE3000_SW1ACONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	if (pmic_reg_write(p, PFUZE3000_SW1ACONF, reg)) {
+		printf("PMIC: Set SW1ACONF error!\n");
+		return -1;
+	}
+
+	/* set SW1B/VDD_SOC_IN step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(p, PFUZE3000_SW1BCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	if (pmic_reg_write(p, PFUZE3000_SW1BCONF, reg)) {
+		printf("PMIC: Set SW1BCONF error!\n");
+		return -1;
+	}
+#if 0
+	/* set VDD_ARM_IN to 1.350V */
+	pmic_reg_read(p, PFUZE3000_SW1AVOLT, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE3000_SW1AB_SETP(13500);
+	if (pmic_reg_write(p, PFUZE3000_SW1AVOLT, reg)) {
+		printf("PMIC: Set SW1AVOLT error!\n");
+		return -1;
+	}
+
+	/* set VDD_SOC_IN to 1.350V */
+	pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+	reg &= ~0x3f;
+	reg |= PFUZE3000_SW1AB_SETP(13500);
+	if (pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg)) {
+		printf("PMIC: Set SW1BVOLT error!\n");
+		return -1;
+	}
+#endif	
+
+	/* set DDR_1_5V to 1.350V */
+	pmic_reg_read(p, PFUZE3000_SW3VOLT, &reg);
+	reg &= ~0x0f;
+	reg |= PFUZE3000_SW3_SETP(13500);
+	if (pmic_reg_write(p, PFUZE3000_SW3VOLT, reg)) {
+		printf("PMIC: Set SW3VOLT error!\n");
+		return -1;
+	}
+
+	/* set VGEN2_1V5 to 1.5V */
+	pmic_reg_read(p, PFUZE3000_VLDO2CTL, &reg);
+	reg &= ~0x0f;
+	reg |= PFUZE3000_VLDO_SETP(15000);
+	/*  enable  */
+	reg |= 0x10;
+	if (pmic_reg_write(p, PFUZE3000_VLDO2CTL, reg)) {
+		printf("PMIC: Set VLDO2CTL error!\n");
+		return -1;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int reg;
+	int is_400M;
+	u32 vddarm;
+	struct pmic *p;
+	
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		
+		p = pmic_get("PFUZE3000");
+
+		/* set VDD_ARM_IN to 1.350V */
+		pmic_reg_read(p, PFUZE3000_SW1AVOLT, &reg);
+		reg &= ~0x3f;
+#if 0
+		reg |= PFUZE3000_SW1AB_SETP(13500);
+		if (pmic_reg_write(p, PFUZE3000_SW1AVOLT, reg)) {
+			printf("PMIC: Set SW1AVOLT error!\n");
+			return;
+		}
+		
+		/* set VDD_SOC_IN to 1.350V */
+		pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+		reg &= ~0x3f;
+		reg |= PFUZE3000_SW1AB_SETP(13500);
+		if (pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg)) {
+			printf("PMIC: Set SW1BVOLT error!\n");
+			return;
+		}
+#endif
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE3000_SW1AB_SETP(10750);
+		else
+			vddarm = PFUZE3000_SW1AB_SETP(11750);
+		
+		pmic_reg_read(p, PFUZE3000_SW1AVOLT, &reg);
+		reg &= ~0x3f;
+		reg |= vddarm;
+		if (pmic_reg_write(p, PFUZE3000_SW1AVOLT, reg)) {
+			printf("PMIC: Set SW1AVOLT error!\n");
+			return;
+		}
+		
+		pmic_reg_read(p, PFUZE3000_SW1BVOLT, &reg);
+		reg &= ~0x3f;
+		reg |= PFUZE3000_SW1AB_SETP(11750);
+		if (pmic_reg_write(p, PFUZE3000_SW1BVOLT, reg)) {
+			printf("PMIC: Set SW1BVOLT error!\n");
+			return;
+		}
+		
+		finish_anatop_bypass();
+		printf("Switched to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+#ifdef CONFIG_MXC_RDC
+static rdc_peri_cfg_t const shared_resources[] = {
+	(RDC_PER_GPIO1 | RDC_DOMAIN(0) | RDC_DOMAIN(1)),
+};
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	/* OGT1 */
+	MX6_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+	/* OTG2 */
+	MX6_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_MXC_RDC
+	imx_rdc_setup_peripherals(shared_resources, ARRAY_SIZE(shared_resources));
+#endif
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+	arch_auxiliary_core_up(0, CONFIG_SYS_AUXCORE_BOOTDATA);
+#endif
+
+	setup_iomux_uart();
+
+	return 0;
+}
+
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC4_BASE_ADDR, 1, 8},
+};
+
+#define USDHC2_PWR_GPIO IMX_GPIO_NR(6, 1)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(6, 2)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1;  // eMMC always present
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+#ifndef CONFIG_SPL_BUILD
+	int i, ret;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC2
+	 * mmc1                    USDHC4
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+			}
+
+			ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+			if (ret) {
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+				return ret;
+			}
+	}
+
+	return 0;
+#else
+	struct src *src_regs = (struct src *)SRC_BASE_ADDR;
+	u32 val;
+	u32 port;
+
+	val = readl(&src_regs->sbmr1);
+
+	if ((val & 0xc0) != 0x40) {
+		printf("Not boot from USDHC!\n");
+		return -EINVAL;
+	}
+
+	port = (val >> 11) & 0x3;
+
+	switch (port) {
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+		usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+		usdhc_cfg[0].esdhc_base = USDHC2_BASE_ADDR;
+		gpio_direction_input(USDHC2_CD_GPIO);
+		gpio_direction_output(USDHC2_PWR_GPIO, 1);
+		break;
+	case 2:
+		imx_iomux_v3_setup_multiple_pads(
+			usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+		usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+		usdhc_cfg[1].esdhc_base = USDHC4_BASE_ADDR;
+		break;
+	}
+
+	gd->arch.sdhc_clk = usdhc_cfg[0].sdhc_clk;
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+#endif
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_HIGH | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_40ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI2_A_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI2_A_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI2_A_DATA_2	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI2_A_DATA_3	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_ALE__QSPI2_A_SS0_B		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI2_A_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/*
+	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
+	 * framwork now and wdog reset will be triggered once set WDOG_B mux
+	 * with default pad setting, we set pad setting here to workaround this.
+	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
+	 * as GPIO mux firstly here to workaround it.
+	 */
+	imx_iomux_v3_setup_pad(wdog_b_pad);
+
+	/* Enable PERI_3V3, which is used by SD2, ENET, LVDS, BT */
+	imx_iomux_v3_setup_multiple_pads(peri_3v3_pads,
+					 ARRAY_SIZE(peri_3v3_pads));
+
+	/* Active high for ncp692 */
+	gpio_direction_output(IMX_GPIO_NR(4, 16) , 1);
+
+	setup_iomux_gpio();
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+#ifdef CONFIG_FSL_QSPI
+	board_qspi_init();
+#endif
+
+	setup_wl1831();
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+	
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	int board_variant = detect_board();
+
+	switch (board_variant) {
+
+		case SECO_B08_TYPE_BASIC:
+			puts("Board: SECO B08 Basic\n");
+			break;
+		case SECO_B08_TYPE_FULL:
+			puts("Board: SECO B08 Full\n");
+			break;
+		default:
+			puts("Unrecognized Seco board\n");
+			break;
+	}
+		
+	return 0;
+}
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	if (!getenv("mmc_cur"))
+		setenv("mmc_cur", "0");
+	if (!getenv("fastboot_dev"))
+		setenv("fastboot_dev", "mmc0");
+	if (!getenv("bootcmd"))
+		setenv("bootcmd", "run udoo_boot_init; boota mmc0");
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+int check_recovery_cmd_file(void)
+{
+	return recovery_check_and_clean_flag();
+}
+
+void board_recovery_setup(void)
+{
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run recoverycmd");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+int isspace(char c)
+{
+	return (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\12');
+}
+char *trim(char *str)
+{
+	char *end;
+
+	// Trim leading space
+	while(isspace(*str)) str++;
+
+	if(*str == 0)  // All spaces?
+	return str;
+
+	// Trim trailing space
+	end = str + strlen(str) - 1;
+	while(end > str && isspace(*end)) end--;
+
+	// Write new null terminator
+	*(end+1) = 0;
+
+	return str;
+}
+
+/**
+ * After loading uEnv.txt, we autodetect which fdt file we need to load and if we should start M4.
+ * uEnv.txt can contain:
+ *  - video_output=hdmi|lvds7|lvds15|disabled
+ *    any other value (or if the variable is not specified) will default to "hdmi"
+ *  - m4_enabled=true|false
+ *    any other value (or if the variable is not specified) will default to "true"
+ *  - use_custom_dtb=true|false
+ *    any other value (or if the variable is not specified) will default to "false"
+ * 
+ * Despite the signature, this command does not accept any argument.
+ */
+int do_udooinit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char* board_revision;
+	char* modelfdt;
+	int board_variant = detect_board();
+	board_revision = detect_revision();
+
+	switch (detect_revision()) {
+		case 0x0:
+			board_revision = "secoboardrev=B";
+			break;
+		case 0x1:
+			board_revision = "secoboardrev=C";
+			break;
+		case 0x2:
+			board_revision = "secoboardrev=D";
+			break;
+		case 0x3:
+			board_revision = "secoboardrev=E";
+			break;
+		case 0x4:
+			board_revision = "secoboardrev=F";
+			break;
+		case 0x5:
+			board_revision = "secoboardrev=G";
+			break;
+		case 0x6:
+			board_revision = "secoboardrev=H";
+			break;
+		case 0x7:
+			board_revision = "secoboardrev=I";
+			break;
+	}
+
+	setenv("b08_board_revision", board_revision);
+	printf("Seco B08 Board revision = %s\n", board_revision);
+	switch (board_variant) {
+		case SECO_B08_TYPE_FULL:
+			modelfdt = "imx6sx-seco-b08-full";
+			break;
+		case SECO_B08_TYPE_BASIC:
+			modelfdt = "imx6sx-seco-b08-basic";
+			break;
+		default:
+			return 0;
+	}
+	
+	char* video_part = "-lvds7";
+	char* video = getenv("video_output");
+	
+	if (video) {
+		video = trim(video);
+		if (strcmp(video, "auto") == 0) {
+			switch(detect_video()) {
+			   case 0x14:
+				video_part = "-rgb7";
+				break;
+			   case 0x55:
+				video_part = "-lvds7";
+				break;
+			   default:
+				break;
+			}
+		} else if (strcmp(video, "lvds7") == 0) {
+			video_part = "-lvds7";
+#ifdef CONFIG_ANDROID_SUPPORT
+			setenv("lcd_density", "128");
+#endif
+		} else if (strcmp(video, "rgb7") == 0) {
+			video_part = "-rgb7";
+		} else if (strcmp(video, "lvds15") == 0) {
+			video_part = "-lvds15";
+		} else if (strcmp(video, "disabled") == 0) {
+			video_part = "";
+		}
+	}
+	
+	char* m4_part = "";
+	char* m4 = getenv("m4_enabled");
+	if (m4) {
+		m4 = trim(m4);
+		if (strcmp(m4, "false") == 0 || strcmp(m4, "no") == 0 || strcmp(m4, "disabled") == 0) {
+			m4_part = "";
+			setenv("m4mmcargs", "");
+			setenv("m4boot", "");
+			printf("M4: disabled via environment variables.\n");
+		} else {
+			m4_part = "-m4";
+			printf("M4: enabled via environment variables.\n");
+		}
+	}
+	
+	char* dir_part = "/dts";
+	char* customdtb = getenv("use_custom_dtb");
+	if (customdtb) {
+		customdtb = trim(customdtb);
+		if (strcmp(customdtb, "true") == 0 || strcmp(customdtb, "yes") == 0 || strcmp(customdtb, "enabled") == 0) {
+			dir_part = "dts-overlay";
+		}
+	}
+	
+	char fdt_file[100];
+	sprintf(fdt_file, "%s/%s%s%s.dtb", dir_part, modelfdt, video_part, m4_part);
+	
+	printf("Device Tree: %s\n", fdt_file);
+	setenv("fdt_file", fdt_file);
+	
+	return 0;
+}
+
+/**
+ * Reset uSD interface pin-muxing. To be lunched after kernel has been loaded in ram.
+ * Despite the signature, this command does not accept any argument.
+ */
+int do_usdreset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	imx_iomux_v3_setup_multiple_pads(
+			usdhc2_pads_reset, ARRAY_SIZE(usdhc2_pads_reset));
+	udelay(100);
+	gpio_direction_output(IMX_GPIO_NR(6,  6) , 0);
+	gpio_direction_output(IMX_GPIO_NR(6,  7) , 0);
+	gpio_direction_output(IMX_GPIO_NR(6,  8) , 0);
+	gpio_direction_output(IMX_GPIO_NR(6,  9) , 0);
+	gpio_direction_output(IMX_GPIO_NR(6, 10) , 0);
+	gpio_direction_output(IMX_GPIO_NR(6, 11) , 0);
+	gpio_direction_output(IMX_GPIO_NR(6,  1) , 0);
+	udelay(100);
+	gpio_set_value(IMX_GPIO_NR(6, 1), 0);
+	printf("uSD interface resetted ..\n");
+	return 0;
+}
+
+U_BOOT_CMD(
+	udooinit,	1,	1,	do_udooinit,
+	"(B08 board) initialize M4 core and determine the device tree to load", ""
+);
+
+U_BOOT_CMD(
+	usdreset,	1,	1,	do_usdreset,
+	"(B08 board) Reset lines of external uSD on B08 board. To be execute before starting kernel.", ""
+);
diff --git a/board/freescale/b08/detectboard.c b/board/freescale/b08/detectboard.c
new file mode 100644
index 0000000..8549490
--- /dev/null
+++ b/board/freescale/b08/detectboard.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/mx6-pins.h>
+#include <i2c.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include "detectboard.h"
+
+#define DIO_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_34ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define DIO_PAD_CFG   (MUX_PAD_CTRL(DIO_PAD_CTRL) | MUX_MODE_SION)
+
+#define BOARD_REV_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_34ohm | PAD_CTL_HYS | PAD_CTL_SRE_FAST)
+
+#define BOARD_REV_PAD_CFG   (MUX_PAD_CTRL(BOARD_REV_PAD_CTRL) | MUX_MODE_SION)
+
+iomux_v3_cfg_t const board_recognition_pads[] = {
+    MX6_PAD_ENET1_COL__GPIO2_IO_0 | DIO_PAD_CFG,  // ENET1_COL conn to ENET2_RST
+};
+#define GPIO_ON_ENET1_COL IMX_GPIO_NR(2, 0)
+
+iomux_v3_cfg_t const board_revision_pads[] = {
+    MX6_PAD_ENET2_COL__GPIO2_IO_6 | BOARD_REV_PAD_CFG,  // BOARD_REV_D0
+    MX6_PAD_ENET2_CRS__GPIO2_IO_7 | BOARD_REV_PAD_CFG,  // BOARD_REV_D1
+    MX6_PAD_KEY_ROW3__GPIO2_IO_18 | BOARD_REV_PAD_CFG,  // BOARD_REV_D2
+};
+#define BOARD_REVISION_BIT_0 IMX_GPIO_NR(2, 6)
+#define BOARD_REVISION_BIT_1 IMX_GPIO_NR(2, 7)
+#define BOARD_REVISION_BIT_2 IMX_GPIO_NR(2, 18)
+
+/**
+ * Detects board revision.
+ * Rev_B = 0x0
+ * Rev_C = 0x1
+ * Rev_D = 0x2
+ * Rev_E = 0x3
+ * Rev_F = 0x4
+ * Rev_G = 0x5
+ * Rev_H = 0x6
+ * Rev_I = 0x7
+ */
+int detect_revision(void)
+{
+    imx_iomux_v3_setup_multiple_pads(board_revision_pads,
+        ARRAY_SIZE(board_revision_pads));
+    
+    gpio_direction_input(BOARD_REVISION_BIT_0);
+    gpio_direction_input(BOARD_REVISION_BIT_1);
+    gpio_direction_input(BOARD_REVISION_BIT_2);
+    
+    int board_rev = gpio_get_value(BOARD_REVISION_BIT_0) << 0 |
+		    gpio_get_value(BOARD_REVISION_BIT_1) << 1 |
+		    gpio_get_value(BOARD_REVISION_BIT_2) << 2 ;
+
+    return board_rev;
+}
+
+/**
+ * Detects the board model.
+ * FULL   - 1GB RAM, 2xEth, WiFi, motion sensors  -> GPIO2_0 = 1
+ * BASIC  - 512 RAM, 1xEth, WiFi, motion sensors  -> GPIO2_0 = 0
+ */
+int detect_board(void)
+{
+    imx_iomux_v3_setup_multiple_pads(board_recognition_pads,
+        ARRAY_SIZE(board_recognition_pads));
+    
+    gpio_direction_input(GPIO_ON_ENET1_COL);
+    
+    int enet2_rst = gpio_get_value(GPIO_ON_ENET1_COL);
+
+    if (enet2_rst == 0)
+    	return SECO_B08_TYPE_BASIC;
+    else
+    	return SECO_B08_TYPE_FULL;
+}
+
+/**
+ * Autodetect video output searching for connected I2C touchsreen address
+ * 0x14 = RGB 7''
+ * 0x55 = LVDS 7''
+ */
+int detect_video(void)
+{
+        I2C_SET_BUS(TOUCH_I2C_BUS);
+        int j, ret=0;
+        struct udevice *bus;
+
+        printf("\ndevice 0x%02x: ", j);
+        for (j = 128; j > 0; j--) {
+           ret = i2c_probe(j);
+           if (ret == 0) {
+                switch(j) {
+                   case 0x14:
+                        printf("Auto-select RGB 7'' video output.\n");
+                        return 0x14;
+                   case 0x55:
+                        printf("Auto-select LVDS 7'' video output.\n");
+                        return 0x55;
+                }
+           }
+        }
+        return 0;
+}
+
diff --git a/board/freescale/b08/detectboard.h b/board/freescale/b08/detectboard.h
new file mode 100644
index 0000000..2dca271
--- /dev/null
+++ b/board/freescale/b08/detectboard.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define SECO_B08_TYPE_BASIC         1
+#define SECO_B08_TYPE_FULL          2
+
+int detect_board(void);
+int detect_video(void);
+int detect_revision(void);
diff --git a/board/freescale/b08/seco_b08.cfg b/board/freescale/b08/seco_b08.cfg
new file mode 100644
index 0000000..973ce49
--- /dev/null
+++ b/board/freescale/b08/seco_b08.cfg
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sxsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX */
+/* DDR IO TYPE */
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+
+/* CLOCK */
+DATA 4 0x020e032c 0x00000030
+
+/* ADDRESS */
+DATA 4 0x020e0300 0x00000020
+DATA 4 0x020e02fc 0x00000020
+DATA 4 0x020e05f4 0x00000020
+
+/* CONTROL */
+DATA 4 0x020e0340 0x00000020
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000020
+DATA 4 0x020e0314 0x00000020
+DATA 4 0x020e0614 0x00000020
+
+/* DATA STROBE */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000028
+DATA 4 0x020e0334 0x00000028
+DATA 4 0x020e0338 0x00000028
+DATA 4 0x020e033c 0x00000028
+
+/* DATA */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+/* Calibrations */
+/* ZQ */
+DATA 4 0x021b0800 0xa1390003
+
+/* write leveling */
+DATA 4 0x021b080c 0x000E000B
+DATA 4 0x021b0810 0x000E0010
+
+/* DQS Read Gate */
+DATA 4 0x021b083c 0x41600158
+DATA 4 0x021b0840 0x01500140
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x3A383E3E
+DATA 4 0x021b0850 0x3A383C38
+
+/* read data bit delay */
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+/* Complete calibration by forced measurment */
+DATA 4 0x021b08b8 0x00000800
+
+/* MMDC init */
+/* in DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000005f
+DATA 4 0x021b0000 0x84190000
+
+/* Initialize MT41K256M16HA-125 */
+/* MR2 */
+DATA 4 0x021b001c 0x04008032
+/* MR3 */
+DATA 4 0x021b001c 0x00008033
+/* MR1 */
+DATA 4 0x021b001c 0x00048031
+/* MR0 */
+DATA 4 0x021b001c 0x05208030
+/* DDR device ZQ calibration */
+DATA 4 0x021b001c 0x04008040
+
+/* final DDR setup, before operation start */
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b001c 0x00000000
+#endif
diff --git a/board/freescale/b08/seco_b08_basic.cfg b/board/freescale/b08/seco_b08_basic.cfg
new file mode 100644
index 0000000..3ce0701
--- /dev/null
+++ b/board/freescale/b08/seco_b08_basic.cfg
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sxsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX */
+/* DDR IO TYPE */
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+
+/* CLOCK */
+DATA 4 0x020e032c 0x00000030
+
+/* ADDRESS */
+DATA 4 0x020e0300 0x00000020
+DATA 4 0x020e02fc 0x00000020
+DATA 4 0x020e05f4 0x00000020
+
+/* CONTROL */
+DATA 4 0x020e0340 0x00000020
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000020
+DATA 4 0x020e0314 0x00000020
+DATA 4 0x020e0614 0x00000020
+
+/* DATA STROBE */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000028
+DATA 4 0x020e0334 0x00000028
+DATA 4 0x020e0338 0x00000028
+DATA 4 0x020e033c 0x00000028
+
+/* DATA */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+/* Calibrations */
+/* ZQ */
+DATA 4 0x021b0800 0xa1390003
+
+/* write leveling */
+DATA 4 0x021b080c 0x001E0022
+DATA 4 0x021b0810 0x001C0019
+
+/* DQS Read Gate */
+DATA 4 0x021b083c 0x41540150
+DATA 4 0x021b0840 0x01440138
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x403E4644
+DATA 4 0x021b0850 0x3C3A4038
+
+/* read data bit delay */
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+/* Complete calibration by forced measurment */
+DATA 4 0x021b08b8 0x00000800
+
+/* MMDC init */
+/* in DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000005f
+DATA 4 0x021b0000 0x83190000
+
+/* Initialize MT41K256M16HA-125 */
+/* MR2 */
+DATA 4 0x021b001c 0x04008032
+/* MR3 */
+DATA 4 0x021b001c 0x00008033
+/* MR1 */
+DATA 4 0x021b001c 0x00048031
+/* MR0 */
+DATA 4 0x021b001c 0x05208030
+/* DDR device ZQ calibration */
+DATA 4 0x021b001c 0x04008040
+
+/* final DDR setup, before operation start */
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b001c 0x00000000
+#endif
diff --git a/board/freescale/b08/spl.c b/board/freescale/b08/spl.c
new file mode 100644
index 0000000..fc6878b
--- /dev/null
+++ b/board/freescale/b08/spl.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) UDOO Team
+ *
+ * Author: Francesco Montefoschi <francesco.monte@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <libfdt.h>
+#include <spl.h>
+#include <asm/arch/mx6-ddr.h>
+#include "detectboard.h"
+
+const struct mx6sx_iomux_ddr_regs mx6_ddr_ioregs = {
+	.dram_dqm0 = 0x00000028,
+	.dram_dqm1 = 0x00000028,
+	.dram_dqm2 = 0x00000028,
+	.dram_dqm3 = 0x00000028,
+	.dram_ras = 0x00000020,
+	.dram_cas = 0x00000020,
+	.dram_odt0 = 0x00000020,
+	.dram_odt1 = 0x00000020,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdcke0 = 0x00003000,
+	.dram_sdcke1 = 0x00003000,
+	.dram_sdclk_0 = 0x00000030,
+	.dram_sdqs0 = 0x00000028,
+	.dram_sdqs1 = 0x00000028,
+	.dram_sdqs2 = 0x00000028,
+	.dram_sdqs3 = 0x00000028,
+	.dram_reset = 0x00000020,
+};
+
+const struct mx6sx_iomux_grp_regs mx6_grp_ioregs = {
+	.grp_addds = 0x00000020,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+	.grp_b0ds = 0x00000028,
+	.grp_b1ds = 0x00000028,
+	.grp_ctlds = 0x00000020,
+	.grp_ddr_type = 0x000c0000,
+	.grp_b2ds = 0x00000028,
+	.grp_b3ds = 0x00000028,
+};
+
+const struct mx6_mmdc_calibration b08_full_mmcd_calib = {
+	.p0_mpwldectrl0 = 0x001B0019,  // done
+	.p0_mpwldectrl1 = 0x001D001D,  // done
+	.p0_mpdgctrl0 = 0x4148013C,    // done
+	.p0_mpdgctrl1 = 0x01340124,    // done
+	.p0_mprddlctl = 0x3C404446,    // done
+	.p0_mpwrdlctl = 0x38383A34,    // done
+};
+
+const struct mx6_mmdc_calibration b08_basic_mmcd_calib = {
+	.p0_mpwldectrl0 = 0x00150015,  // done
+	.p0_mpwldectrl1 = 0x00170014,  // done
+	.p0_mpdgctrl0 = 0x41480140,    // done
+	.p0_mpdgctrl1 = 0x0138012C,    // done
+	.p0_mprddlctl = 0x403E4248,    // done
+	.p0_mpwrdlctl = 0x3A383A36,    // done
+};
+
+/* MT41K256M16 */
+static struct mx6_ddr3_cfg b08_full_mem_ddr = {
+	.mem_speed = 1600,
+	.density = 4,
+	.width = 32,
+	.banks = 8,
+	.rowaddr = 15,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+};
+
+/* MT41K128M16 */
+static struct mx6_ddr3_cfg b08_basic_mem_ddr = {
+	.mem_speed = 1600,
+	.density = 2,
+	.width = 16,
+	.banks = 8,
+	.rowaddr = 14,
+	.coladdr = 10,
+	.pagesz = 2,
+	.trcd = 1375,
+	.trcmin = 4875,
+	.trasmin = 3500,
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0xFFFFFFFF, &ccm->CCGR0);
+	writel(0xFFFFFFFF, &ccm->CCGR1);
+	writel(0xFFFFFFFF, &ccm->CCGR2);
+	writel(0xFFFFFFFF, &ccm->CCGR3);
+	writel(0xFFFFFFFF, &ccm->CCGR4);
+	writel(0xFFFFFFFF, &ccm->CCGR5);
+	writel(0xFFFFFFFF, &ccm->CCGR6);
+	writel(0xFFFFFFFF, &ccm->CCGR7);
+}
+
+static void spl_dram_init(void)
+{
+	int board = detect_board();
+	
+	struct mx6_ddr_sysinfo sysinfo = {
+		.dsize = b08_full_mem_ddr.width/32,
+		.cs_density = 24,
+		.ncs = 1,
+		.cs1_mirror = 0,
+		.rtt_wr = 2,
+		.rtt_nom = 2,		/* RTT_Nom = RZQ/2 */
+		.walat = 1,		/* Write additional latency */
+		.ralat = 5,		/* Read additional latency */
+		.mif3_mode = 3,		/* Command prediction working mode */
+		.bi_on = 1,		/* Bank interleaving enabled */
+		.sde_to_rst = 0x10,	/* 14 cycles, 200us (JEDEC default) */
+		.rst_to_cke = 0x23,	/* 33 cycles, 500us (JEDEC default) */
+	};
+
+	if (board == SECO_B08_TYPE_BASIC) {
+		puts("Setting 512MB RAM calibration data\n");
+		mx6sx_dram_iocfg(b08_basic_mem_ddr.width, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+		mx6_dram_cfg(&sysinfo, &b08_basic_mmcd_calib, &b08_basic_mem_ddr);
+		((struct mmdc_p_regs *)MX6_MMDC_P0_MDCTL)->mdctl = 0x83190000;
+	} else {
+		puts("Setting 1024MB RAM calibration data\n");
+		mx6sx_dram_iocfg(b08_full_mem_ddr.width, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+		mx6_dram_cfg(&sysinfo, &b08_full_mmcd_calib, &b08_full_mem_ddr);
+		((struct mmdc_p_regs *)MX6_MMDC_P0_MDCTL)->mdctl = 0x84190000;
+	}
+}
+
+void board_init_f(ulong dummy)
+{
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+
+	ccgr_init();
+
+	/* iomux and setup of i2c */
+	board_early_init_f();
+
+	/* setup GP timer */
+	timer_init();
+
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+
+void reset_cpu(ulong addr)
+{
+}
diff --git a/board/freescale/common/Makefile b/board/freescale/common/Makefile
index 73ba0ae..9b05629 100644
--- a/board/freescale/common/Makefile
+++ b/board/freescale/common/Makefile
@@ -60,7 +60,8 @@ obj-$(CONFIG_P5040DS)		+= ics307_clk.o
 obj-$(CONFIG_VSC_CROSSBAR)    += vsc3316_3308.o
 obj-$(CONFIG_IDT8T49N222A)	+= idt8t49n222a_serdes_clk.o
 obj-$(CONFIG_ZM7300)		+= zm7300.o
-obj-$(CONFIG_POWER_PFUZE100)	+= pfuze.o
+obj-$(CONFIG_POWER_PFUZE100)   += pfuze.o
+obj-$(CONFIG_POWER_PFUZE3000)	+= pfuze.o
 obj-$(CONFIG_MXC_EPDC)		+= epdc_setup.o
 obj-y				+= mmc.o
 ifdef CONFIG_FSL_FASTBOOT
diff --git a/board/freescale/common/pfuze.c b/board/freescale/common/pfuze.c
index 69afa83..cb1896e 100644
--- a/board/freescale/common/pfuze.c
+++ b/board/freescale/common/pfuze.c
@@ -54,11 +54,19 @@ struct pmic *pfuze_common_init(unsigned char i2cbus)
 	int ret;
 	unsigned int reg;
 
+#ifdef CONFIG_POWER_PFUZE3000
+	ret = power_pfuze3000_init(i2cbus);
+#else
 	ret = power_pfuze100_init(i2cbus);
+#endif
 	if (ret)
 		return NULL;
 
+#ifdef CONFIG_POWER_PFUZE3000
+	p = pmic_get("PFUZE3000");
+#else
 	p = pmic_get("PFUZE100");
+#endif
 	ret = pmic_probe(p);
 	if (ret)
 		return NULL;
@@ -90,6 +98,9 @@ struct pmic *pfuze_common_init(unsigned char i2cbus)
 	reg |= SW1xCONF_DVSSPEED_4US;
 	pmic_reg_write(p, PFUZE100_SW1CCONF, reg);
 
+	/* Set SW4VOL to 1200mV */
+	pmic_reg_write(p, PFUZE100_SW4VOL, 0x23);
+
 	return p;
 }
 #endif
diff --git a/configs/seco_b08_defconfig b/configs/seco_b08_defconfig
new file mode 100644
index 0000000..5eb7337
--- /dev/null
+++ b/configs/seco_b08_defconfig
@@ -0,0 +1,5 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_SECO_B08=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/b08/seco_b08.cfg"
+CONFIG_CMD_GPIO=y
diff --git a/include/config_cmd_default.h b/include/config_cmd_default.h
new file mode 100644
index 0000000..e79a13b
--- /dev/null
+++ b/include/config_cmd_default.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License Version 2. This file is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef _CONFIG_CMD_DEFAULT_H
+#define _CONFIG_CMD_DEFAULT_H
+
+/*
+ * Alphabetical list of all commands that are configured by default.
+ * This is essentially all commands minus those that are considered
+ * "non-standard" for some reason (memory hogs, requires special
+ * hardware, not fully tested, etc.).
+ */
+
+#define CONFIG_CMD_BDI		/* bdinfo			*/
+#define CONFIG_CMD_BOOTD	/* bootd			*/
+#define CONFIG_CMD_CONSOLE	/* coninfo			*/
+#define CONFIG_CMD_ECHO		/* echo arguments		*/
+#define CONFIG_CMD_EDITENV	/* editenv			*/
+#define CONFIG_CMD_ENV_EXISTS	/* query whether env variables exists */
+#define CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#define CONFIG_CMD_IMI		/* iminfo			*/
+#define CONFIG_CMD_ITEST	/* Integer (and string) test	*/
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_CMD_FLASH	/* flinfo, erase, protect	*/
+#define CONFIG_CMD_IMLS		/* List all found images	*/
+#endif
+#define CONFIG_CMD_LOADB	/* loadb			*/
+#define CONFIG_CMD_LOADS	/* loads			*/
+#define CONFIG_CMD_MEMORY	/* md mm nm mw cp cmp crc base loop */
+#define CONFIG_CMD_MISC		/* Misc functions like sleep etc*/
+#define CONFIG_CMD_NET		/* bootp, tftpboot, rarpboot	*/
+#define CONFIG_CMD_NFS		/* NFS support			*/
+#define CONFIG_CMD_RUN		/* run command in env variable	*/
+#define CONFIG_CMD_SAVEENV	/* saveenv			*/
+#define CONFIG_CMD_SETGETDCR	/* DCR support on 4xx		*/
+#define CONFIG_CMD_SOURCE	/* "source" command support	*/
+#define CONFIG_CMD_XIMG		/* Load part of Multi Image	*/
+
+#endif	/* _CONFIG_CMD_DEFAULT_H */
diff --git a/include/configs/seco_b08.h b/include/configs/seco_b08.h
new file mode 100644
index 0000000..b8ad6d8
--- /dev/null
+++ b/include/configs/seco_b08.h
@@ -0,0 +1,446 @@
+/*
+ * Copyright 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright Jasbir Matharu
+ * Copyright 2015 UDOO Team
+ *
+ * Configuration settings for Seco B08 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+
+#include "mx6_common.h"
+
+#include <asm/imx-common/gpio.h>
+/*
+#define CONFIG_MX6
+#define CONFIG_ROM_UNIFIED_SECTIONS
+*/
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_MMC_SUPPORT
+#include "imx6_spl.h"
+#endif
+
+#define CONFIG_SYS_UBOOT_BASE		CONFIG_SYS_TEXT_BASE
+
+#include "seco_b08_bootdevice.h"
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_SPL_FSL_QSPI
+#define CONFIG_SPL_SPI_SUPPORT
+#define CONFIG_SPL_SPI_CS		0
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_MODE             0
+#define CONFIG_ENV_SPI_MAX_HZ           10000000
+#define CONFIG_ENV_SECT_SIZE           (64 * 1024)
+#define CONFIG_SYS_SPI_U_BOOT_OFFS		0x12000
+#endif
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+/*
+#define CONFIG_SYS_GENERIC_BOARD
+*/
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+/* MMC Configuration */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#undef CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define CONFIG_BAUDRATE			115200
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+/* Needed for uEnv.txt support */
+/*#undef CONFIG_CMD_EXPORTENV*/
+/*#undef CONFIG_CMD_IMPORTENV*/
+
+/* Network */
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+/*
+#define CONFIG_CMD_NFS
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+*/
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 0
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x0
+#define CONFIG_FEC_XCV_TYPE             RMII
+#define CONFIG_ETHPRIME                 "FEC0"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1         /* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2         /* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3         /* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* Touchscreen for autodetect */
+#define TOUCH_I2C_BUS			0
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+#define PFUZE3000_I2C_BUS	0
+
+/* Command definition */
+/*
+#include <config_cmd_default.h>
+*/
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x78000000 /* Set to QSPI2 B flash at default */
+#ifndef CONFIG_SYS_AUXCORE_FASTUP
+/*
+#define CONFIG_CMD_SETEXPR
+*/
+#endif
+
+#ifdef CONFIG_CMD_BOOTAUX
+#define M4_STARTUP_ENV \
+	"m4last=/var/opt/m4/m4last.fw\0" \
+	"m4fw=/m4startup.fw\0" \
+	"mmcrootpart=2\0" \
+	"m4last_cmd=ext2load mmc ${mmcdev}:${mmcrootpart} 0x84000000 ${m4last};\0" \
+	"m4fw_cmd=fatload mmc ${mmcdev}:${mmcpart} 0x84000000 ${m4fw}; bootaux 0x84000000\0" \
+	"m4boot=if run m4last_cmd ; then bootaux 0x84000000 ; else run m4fw_cmd ; fi\0" \
+	"m4mmcargs=uart_from_osc clk_ignore_unused cpuidle.off=1\0"
+#else
+#define M4_STARTUP_ENV \
+	"m4boot=\0" \
+	"m4mmcargs=uart_from_osc clk_ignore_unused cpuidle.off=1\0"
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=Hannstar-XGA\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x78000000 /* Set to QSPI2 B flash at default */
+#define CONFIG_IMX_BOOTAUX
+
+/* When using M4 fastup demo, no need these M4 env, since QSPI is used by M4 */
+#ifndef CONFIG_SYS_AUXCORE_FASTUP
+#define UPDATE_M4_ENV \
+        "m4image=m4_qspi.bin\0" \
+        "loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+        "update_m4_from_sd=" \
+                "if sf probe 1:0; then " \
+                        "if run loadm4image; then " \
+                                "setexpr fw_sz ${filesize} + 0xffff; " \
+                                "setexpr fw_sz ${fw_sz} / 0x10000; "    \
+                                "setexpr fw_sz ${fw_sz} * 0x10000; "    \
+                                "sf erase 0x0 ${fw_sz}; " \
+                                "sf write ${loadaddr} 0x0 ${filesize}; " \
+                        "fi; " \
+                "fi\0" \
+        "m4boot=sf probe 1:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+/* Linux only */
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+/* Linux only */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6sx-seco-b08-full-lvds7.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"panel=Hannstar-XGA\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+
+/* #define CONFIG_SYS_BOOTM_LEN	(16 << 20) */
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_QSPI_BASE			QSPI2_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI2_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#ifdef CONFIG_FSL_QSPI
+#define CONFIG_SYS_MMC_ENV_DEV		1  /*USDHC4 eMMC*/
+#define CONFIG_MMCROOT			"/dev/mmcblk" 
+#else
+#define CONFIG_SYS_MMC_ENV_DEV		0  /*USDHC2*/
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+/* #define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS */
+/* #define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS */
+/* #define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE */
+/* #define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED */
+#endif
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_VIDEO_GIS
+#define CONFIG_VIDEO_CSI
+#define CONFIG_VIDEO_PXP
+#define CONFIG_VIDEO_VADC
+#endif
+#endif
+
+#define CONFIG_CMD_USB
+#ifdef CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#endif
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#define CONFIG_OF_LOAD_MANUALLY
+#define CONFIG_CMD_BOOTI
+#include "mx6sxsabresdandroid.h"
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"kernel_loadaddr=0x84808000\0" \
+	"fdt_loadaddr=0x85700000\0" \
+	"script=uEnv.txt\0" \
+	"loadbootscript=" \
+		"ext2load mmc 0:4 ${kernel_loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"env import -t ${kernel_loadaddr} ${filesize};\0" \
+	"udoo_boot_init=" \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"fi; " \
+		"udooinit; " \
+		"ext2load mmc 0:5 ${fdt_loadaddr} ${fdt_file}; \0" \
+	"splashpos=m,m\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"recoverycmd=run udoo_boot_init; boota mmc0 recovery\0"
+#endif
+
+/*
+#define CONFIG_CMD_TIME
+*/
+
+#endif				/* __CONFIG_H */
diff --git a/include/configs/seco_b08_bootdevice.h b/include/configs/seco_b08_bootdevice.h
new file mode 100644
index 0000000..1d08a75
--- /dev/null
+++ b/include/configs/seco_b08_bootdevice.h
@@ -0,0 +1 @@
+#define CONFIG_ENV_IS_IN_MMC
diff --git a/include/power/pfuze3000_pmic.h b/include/power/pfuze3000_pmic.h
index 42e494c..e7822a0 100644
--- a/include/power/pfuze3000_pmic.h
+++ b/include/power/pfuze3000_pmic.h
@@ -74,6 +74,8 @@ enum {
 };
 
 #define PFUZE3000_SW1AB_SETP(x) (((x) - 700) / 25)
+#define PFUZE3000_SW3_SETP(x)      ((x - 9000) / 500)
+#define PFUZE3000_VLDO_SETP(x)     ((x - 8000) / 500)
 
 int power_pfuze3000_init(unsigned char bus);
 
-- 
2.7.4

